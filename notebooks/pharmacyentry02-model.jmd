---
title       : "Assignment: pharmacy entry"
subtitle    : "Part IV-??" 
author      : Paul Schrimpf
date        : `j using Dates; print(Dates.today())`
bibliography: "entry.bib"
link-citations: true
---

<a rel="license"
href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative
Commons License" style="border-width:0"
src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png"
/></a><br />This work is licensed under a <a rel="license"
href="http://creativecommons.org/licenses/by-sa/4.0/">Creative
Commons Attribution-ShareAlike 4.0 International License</a>.

### About this document {-}

This document was created using Weave.jl. The code is available in
[on github](https://github.com/ECON567/PharmacyEntry). The same
document generates both static webpages and associated jupyter
notebooks. 

$$
\def\indep{\perp\!\!\!\perp}
\def\Er{\mathrm{E}}
\def\R{\mathbb{R}}
\def\En{{\mathbb{E}_n}}
\def\Pr{\mathrm{P}}
\newcommand{\norm}[1]{\left\Vert {#1} \right\Vert}
\newcommand{\abs}[1]{\left\vert {#1} \right\vert}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\def\inprob{\,{\buildrel p \over \rightarrow}\,} 
\def\indist{\,{\buildrel d \over \rightarrow}\,} 
$$

```julia
using Pkg 
Pkg.activate("..") 
Pkg.resolve()

using Revise
if (!("../src" ∈ LOAD_PATH))
  push!(LOAD_PATH, "../src") 
end
using PharmacyEntry
```

# Part IV - Model

As in @br1991, we will assume that the profits per pharmacy in
market $m$ with $N$ pharmacies is 

$$
\begin{align*}
    \pi_{m,N} = s_m \underbrace{(\alpha_1 + x_m\beta + \sum_{n=2}^N
    \alpha_n)}_{\text{variable profits}} - \underbrace{\left(\gamma_1 + \delta
    w_m + \sum_{n=2}^N \gamma_n \right)}_{\text{fixed costs}} +
    \epsilon_m 
\end{align*}
$$

where $s_m$ is the size of the market. To simplify, I am omitting the
$\lambda$ and the other size shifting variables from the model. You may add
these if you wish. 

Let $\theta = (\alpha, \beta, \gamma)$ denote the model parameters.
If we assume $\epsilon_m$ has cdf $F_\epsilon()$ (conditional on $s$,
$x$, and $w$), then the likelihood of observing $N_m$ pharmacies in
market $m$ is

$$
\begin{align*}
   P(N = N_m | s_m, x_m, w_m; \theta) = & P(\pi_{m,N} \geq 0 \;\&\;
   \pi_{m,N+1} < 0) \\
   = & P\left(-\left[s_m (\alpha_1 + x_m\beta + \sum_{n=2}^{N_m}
    \alpha_n) - \left(\gamma_1 + \delta
    w_m + \sum_{n=2}^{N_m} \gamma_n \right)\right] \leq
    \epsilon_m \leq -\left[s_m (\alpha_1 + x_m\beta + \sum_{n=2}^{N_m+1}
    \alpha_n) - \left(\gamma_1 + \delta
    w_m + \sum_{n=2}^{N_m+1} \gamma_n \right)\right] \right) \\
   = & F_\epsilon\left(-\left[s_m (\alpha_1 + x_m\beta + \sum_{n=2}^{N_m+1}
    \alpha_n) - \left(\gamma_1 + \delta
    w_m + \sum_{n=2}^{N_m+1} \gamma_n \right)\right]\right) -
    F_\epsilon\left( -\left[s_m (\alpha_1 + x_m\beta + \sum_{n=2}^{N_m}
    \alpha_n) - \left(\gamma_1 + \delta
    w_m + \sum_{n=2}^{N_m} \gamma_n \right)\right] \right)
\end{align*}
$$

The loglikelihood is then

$$
\mathcal{L}(\theta) = \sum_{m=1}^M \log P(N = N_m | s_m, x_m, w_m;
\theta),
$$

and $\theta$ can be estimated by maximizing,

$$
\hat{\theta} = \argmax_\theta \mathcal{L}(\theta).
$$

### Problem 1: loglikelihood

Write a function to compute the loglikelihood. You may do this however
you want, but I suggest using the following skeleton code.
```julia; eval=false
using Distributions

"""
         brentrymodel(data::AbstractDataFrame,
                      n::Symbol,
                      s::Symbol,
                      x::Array{Symbol,1},
                      w::Array{Symbol,1};
                      Fϵ)

Create loglikelihood for Bresnehan & Reiss style entry model

Inputs:
- `data` DataFrame 
- `n` name of number of firm variable in data
- `s` name of market size variable in data
- `x` array of names of variable profit shifters
- `w` array of names of fixed cost shifters 
- `Fϵ` cdf of ϵ, optional, defaults to standard normal cdf

The same variables may be included in both `x` and `w`.


"""
function brentrymodel(data::AbstractDataFrame,
                      n::Symbol,
                      s::Symbol,
                      x::Array{Symbol,1},
                      w::Array{Symbol,1};
                      Fϵ = x->cdf(Normal(),x))
  # skip observations with missings
  vars = [n, s, x..., w...]
  inc = completecases(data[vars])

  N = disallowmissing(data[n][inc])
  S = disallowmissing(data[s][inc])
  X = disallowmissing(convert(Matrix, data[x][inc,:]))
  W = disallowmissing(convert(Matrix, data[w][inc,:]))
  Nmax = maximum(N)
  function packparam(α,β,γ,δ)
    θ = (α,β,γ,δ)
  end
  function unpackparam(θ)
    α = θ[1:Nmax]
    β = θ[(Nmax+1):(Nmax+size(X,2))]
    γ = θ[(Nmax+size(X,2)+1):(Nmax+size(X,2)+Nmax)]
    δ = θ[(Nmax+size(X,2)+Nmax+1):end]
    (α,β,γ,δ)
  end
  function loglike(θ)
    (α,β,γ,δ) = unpackparam(θ)
    error("You must write the body of this function")    
  end
  
  return(loglike=loglike, unpack=unpackparam, pack=packparam)
end

```

### Problem 2: estimate on simulated data 

It is good practice to test any estimation method on simulated
data. The function `brentrysim` in `PharmacyEntry/src/entrymodel.jl`
simulates this model. Use it to test your likelihood. Here is some
code to simulate. You may need to adjust the parameters to get a
decent distribution of number of firms (i.e. not all 0 or 5).
```julia
# Simulating data
using DataFrames, Statistics
import CSV
df = CSV.read("cleandata.csv")

# parameters for simulation
α = [-0.13, -0.29, -0.19, -0.2, -0.1] # loosely taken from Bresnehan & Reiss
                                      # Table 4, note that my
                                      # notation has α[2:n] equal to
                                      # their -α[2:n]
γ = [0.5,   1.,  1.,  1., 1.]
# you may have to adjust the parameters to get a reasonable distribution of
# number of pharmacies across markets
svar = Symbol("Population, 2016")
α = α./mean(df[svar])  # scale to fit this data better
β = [1., 10., 2.]
xvars = [Symbol("Employment rate"),
         Symbol("Average total income in 2015 among recipients (\$)"),
         Symbol("65 years and over")]
for j in 1:length(β)
  β[j] = β[j] / mean(df[xvars[j]].*df[svar])
end
δ = [1., 1.]
wvars = [Symbol("Population density per square kilometre"),
         Symbol("Land area in square kilometres")]
for j in 1:length(δ)
  δ[j] = δ[j] / maximum(df[wvars[j]])
end

df[:nsim] = brentrysim(df, svar, xvars, wvars, α,β,γ,δ)
println("Distribution of number of firms")
for i in 0:length(α)
  println("$(mean(df[:nsim].==i))") 
end

S = df[svar]
sag = zeros(length(S), length(α))
for c in 1:length(α)
  sag[:,c] = S*cumsum(α)[c] .- cumsum(γ)[c]
end

```

To estimate from the simulated data, you could do the following.
```julia; eval=false
using Optim
try 
  using EntrySolution
  # this contains my code for the likelihood and
  # such, it's intentionally not included in the assignment
catch
end

(loglike, unpack, pack) = brentrymodel(df, :nsim, svar, xvars, wvars)
θ0 = pack(α,β,γ,δ)
loglike(θ0)

# initial values --- note that you may run into optimization problems if
# s*cumsum(α)[c] - cumsum(γ)[c] is not decreasing with c. You can
# ensure this by making α < 0 and γ>0
βi = zeros(size(β))
δi = zeros(size(δ))
αi = zeros(size(α))
γi = γ
θi = pack(αi, βi, γi, δi)
loglike(θ0)

res = optimize((x)->(-loglike(x)), θ0, method=BFGS(), autodiff=:forward, show_trace=true)
θhat = res.minimizer
(αhat, βhat, γhat, δhat) = unpack(θhat)

```
Ideally, you would do this many times, and verify that on average the
estimates are close to the true parameters. 


TO BE CONTINUED
